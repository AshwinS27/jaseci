\subsection{APIs for actions}

\par
The set action APIs enable the manual management of Jaseci actions and action
libraries/sets. Action libraries can be loaded locally into the running instance of
the python program, or as a remote container linked action library. In this mode,
action libraries operate as micro-services. Jaseci will be able to dynamically
and automatically make this decision for the user based on online monitoring and
performance profiling.

\apispec{actions load local (api: actions\_load\_local)}{file: str (*req)}
{This API will dynamically load a module based on a python file. This API also
makes an attempt to auto detect and hot load any python package dependencies
the file may reference via python's relative imports. This file is assumed to
have the necessary annotations and decorations required by Jaseci to recognize
its actions.\vspace{4mm}\par
\argspec{
\texttt{file} -- The python file to load actions from.\par
}}
\apispec{actions load remote (api: actions\_load\_remote)}{url: str (*req)}
{No documentation yet.}
\apispec{actions load module (api: actions\_load\_module)}{mod: str (*req)}
{No documentation yet.}
\apispec{actions list (api: actions\_list)}{name: str}
{No documentation yet.}
\subsection{APIs for alias}

\par
The alias set of APIs provide a set of `alias' management functions for
creating and managing aliases for long strings such as UUIDs. If an alias'
name is used as a parameter value in any API call, that parameter will see
the alias' value instead. Given that references to all sentinels, walkers,
nodes, etc. utilize UUIDs, it becomes quite useful to create pneumonic
names for them. Also, when registering   sentinels, walkers, architype
handy aliases are automatically generated. These generated aliases can
then be managed using the alias APIs. Keep in mind that whenever an alias
is created, all parameter values submitted to any API with the alias name
will be replaced internally by its value. If you get in a bind, simply use
the clear or delete alias APIs.

\apispec{alias register (api: alias\_register)}{name: str (*req), value: str (*req)}
{Either create new alias string to string mappings or replace
an existing mappings of a given alias name. Once registered the
alias mapping is instantly active.\vspace{4mm}\par
\argspec{
\texttt{name} -- The name for the alias created by caller.\par

\texttt{value} -- The value for that name to map to (i.e., UUID)\par
}}
\apispec{alias list (api: alias\_list)}{n/a}
{Returns dictionary object of name to value mappings currently active.
This API is quite useful to track not only the aliases the caller
creates, but also the aliases automatically created as various Jaseci
objects (walkers, architypes, sentinels, etc.) are created, changed,
or destroyed.}
\apispec{alias delete (api: alias\_delete)}{name: str (*req)}
{Removes a specific alias by its name. Only the alias is removed no
actual objects are affected. Future uses of this name will not be
mapped.\vspace{4mm}\par
\argspec{
\texttt{name} -- The name for the alias to be removed from caller.\par
}}
\apispec{alias clear (api: alias\_clear)}{n/a}
{Removes a all aliases. No actual objects are affected. Aliases will
continue to be automatically generated when creating other Jaseci
objects.}
\subsection{APIs for architype}

\par
The architype set of APIs allow for the addition and removing of
architypes. Given a Jac implementation of an architype these APIs are
designed for creating, compiling, and managing architypes that can be
used by Jaseci. There are two ways to add an architype to Jaseci, either
through the management of sentinels using the sentinel API, or by
registering independent architypes with these architype APIs. These
APIs are also used for inspecting and managing existing arichtypes that
a Jaseci instance is aware of.

\apispec{architype register (api: architype\_register)}{code: str (*req), encoded: bool, snt: sentinel}
{This register API allows for the creation or replacement/update of
an architype that can then be used by walkers in their interactions
of graphs. The code argument takes Jac source code for the single
architype. To load multiple architypes and walkers at the same time,
use sentinel register API.\vspace{4mm}\par
\argspec{
\texttt{code} -- The text (or filename) for an architypes Jac code\par

\texttt{encoded} -- True/False flag as to whether code is encode
in base64\par

\texttt{snt} -- The UUID of the sentinel to be the owner of this
architype\par
}}
\apispec{architype get (api: architype\_get)}{arch: architype (*req), mode: str, detailed: bool}
{No documentation yet.\vspace{4mm}\par
\argspec{
\texttt{arch} -- The architype being accessed\par

\texttt{mode} -- Valid modes: {default, code, ir, }\par

\texttt{detailed} -- Flag to give summary or complete set of fields\par
}}
\apispec{architype set (api: architype\_set)}{arch: architype (*req), code: str (*req), mode: str}
{No documentation yet.\vspace{4mm}\par
\argspec{
\texttt{arch} -- The architype being set\par

\texttt{code} -- The text (or filename) for an architypes Jac code/ir\par

\texttt{mode} -- Valid modes: {default, code, ir, }\par
}}
\apispec{architype list (api: architype\_list)}{snt: sentinel, detailed: bool}
{No documentation yet.\vspace{4mm}\par
\argspec{
\texttt{snt} -- The sentinel for which to list its architypes\par

\texttt{detailed} -- Flag to give summary or complete set of fields\par
}}
\apispec{architype delete (api: architype\_delete)}{arch: architype (*req), snt: sentinel}
{No documentation yet.\vspace{4mm}\par
\argspec{
\texttt{arch} -- The architype being set\par

\texttt{snt} -- The sentinel for which to list its architypes\par
}}
\subsection{APIs for config}

Abstracted since there are no valid configs in core atm, see jaseci\_serv
to see how used.

\apispec{config get (api: config\_get)}{name: str (*req), do_check: bool}
{No documentation yet.}
\apispec{config set (api: config\_set)}{name: str (*req), value: str (*req), do_check: bool}
{No documentation yet.}
\apispec{config list (api: config\_list)}{n/a}
{No documentation yet.}
\apispec{config index (api: config\_index)}{n/a}
{No documentation yet.}
\apispec{config exists (api: config\_exists)}{name: str (*req)}
{No documentation yet.}
\apispec{config delete (api: config\_delete)}{name: str (*req), do_check: bool}
{No documentation yet.}
\subsection{APIs for global}

No documentation yet.

\apispec{global set (api: global\_set)}{name: str (*req), value: str (*req)}
{No documentation yet.}
\apispec{global delete (api: global\_delete)}{name: str (*req)}
{No documentation yet.}
\apispec{global sentinel set (api: global\_sentinel\_set)}{snt: sentinel}
{No documentation yet.}
\apispec{global sentinel unset (api: global\_sentinel\_unset)}{n/a}
{No documentation yet.}
\subsection{APIs for graph}

No documentation yet.

\apispec{graph create (api: graph\_create)}{set_active: bool}
{No documentation yet.}
\apispec{graph get (api: graph\_get)}{gph: graph, mode: str, detailed: bool}
{Valid modes: {default, dot, }}
\apispec{graph list (api: graph\_list)}{detailed: bool}
{No documentation yet.}
\apispec{graph active set (api: graph\_active\_set)}{gph: graph (*req)}
{No documentation yet.}
\apispec{graph active unset (api: graph\_active\_unset)}{n/a}
{No documentation yet.}
\apispec{graph active get (api: graph\_active\_get)}{detailed: bool}
{No documentation yet.}
\apispec{graph delete (api: graph\_delete)}{gph: graph (*req)}
{No documentation yet.}
\apispec{graph node get (api: graph\_node\_get)}{nd: node (*req), ctx: list}
{No documentation yet.}
\apispec{graph node set (api: graph\_node\_set)}{nd: node (*req), ctx: dict (*req), snt: sentinel}
{No documentation yet.}
\subsection{APIs for jac}

No documentation yet.

\subsection{APIs for logger}

No documentation yet.

\apispec{logger http connect (api: logger\_http\_connect)}{host: str (*req), port: int (*req), url: str (*req), log: str}
{Valid log params: {sys, app, all }}
\apispec{logger http clear (api: logger\_http\_clear)}{log: str}
{Valid log params: {sys, app, all }}
\apispec{logger list (api: logger\_list)}{n/a}
{No documentation yet.}
\subsection{APIs for master}

No documentation yet.

\apispec{master create (api: master\_create)}{name: str (*req), set_active: bool, other_fields: dict}
{other fields used for additional feilds for overloaded interfaces
(i.e., Dango interface)}
\apispec{master get (api: master\_get)}{name: str (*req), mode: str, detailed: bool}
{Valid modes: {default, }}
\apispec{master list (api: master\_list)}{detailed: bool}
{No documentation yet.}
\apispec{master active set (api: master\_active\_set)}{name: str (*req)}
{NOTE: Specail handler included in general interface to api}
\apispec{master active unset (api: master\_active\_unset)}{n/a}
{No documentation yet.}
\apispec{master active get (api: master\_active\_get)}{detailed: bool}
{No documentation yet.}
\apispec{master self (api: master\_self)}{detailed: bool}
{No documentation yet.}
\apispec{master delete (api: master\_delete)}{name: str (*req)}
{No documentation yet.}
\subsection{APIs for object}

\par
...

\apispec{global get (api: global\_get)}{name: str (*req)}
{No documentation yet.}
\apispec{object get (api: object\_get)}{obj: element (*req), depth: int, detailed: bool}
{No documentation yet.}
\apispec{object perms get (api: object\_perms\_get)}{obj: element (*req)}
{No documentation yet.}
\apispec{object perms set (api: object\_perms\_set)}{obj: element (*req), mode: str (*req)}
{No documentation yet.}
\apispec{object perms default (api: object\_perms\_default)}{mode: str (*req)}
{No documentation yet.}
\apispec{object perms grant (api: object\_perms\_grant)}{obj: element (*req), mast: element (*req), read_only: bool}
{No documentation yet.}
\apispec{object perms revoke (api: object\_perms\_revoke)}{obj: element (*req), mast: element (*req)}
{No documentation yet.}
\subsection{APIs for sentinel}

No documentation yet.

\apispec{sentinel register (api: sentinel\_register)}{name: str, code: str, code_dir: str, mode: str, encoded: bool, auto_run: str, auto_gen_graph: bool, ctx: dict, set_active: bool}
{Auto run is the walker to execute on register (assumes active graph
is selected)}
\apispec{sentinel pull (api: sentinel\_pull)}{set_active: bool, on_demand: bool}
{No documentation yet.}
\apispec{sentinel get (api: sentinel\_get)}{snt: sentinel, mode: str, detailed: bool}
{Valid modes: {default, code, ir, }}
\apispec{sentinel set (api: sentinel\_set)}{code: str (*req), code_dir: str, encoded: bool, snt: sentinel, mode: str}
{Valid modes: {code, ir, }}
\apispec{sentinel list (api: sentinel\_list)}{detailed: bool}
{No documentation yet.}
\apispec{sentinel test (api: sentinel\_test)}{snt: sentinel, detailed: bool}
{No documentation yet.}
\apispec{sentinel active set (api: sentinel\_active\_set)}{snt: sentinel (*req)}
{No documentation yet.}
\apispec{sentinel active unset (api: sentinel\_active\_unset)}{n/a}
{No documentation yet.}
\apispec{sentinel active global (api: sentinel\_active\_global)}{detailed: bool}
{Exclusive OR with pull strategy}
\apispec{sentinel active get (api: sentinel\_active\_get)}{detailed: bool}
{No documentation yet.}
\apispec{sentinel delete (api: sentinel\_delete)}{snt: sentinel (*req)}
{No documentation yet.}
\subsection{APIs for stripe}

Set of APIs to expose jaseci stripe management

\apispec{stripe product create (api: stripe\_product\_create)}{name: str, description: str}
{No documentation yet.}
\apispec{stripe product price set (api: stripe\_product\_price\_set)}{productId: str (*req), amount: float, interval: str}
{No documentation yet.}
\apispec{stripe product list (api: stripe\_product\_list)}{detalied: bool}
{No documentation yet.}
\apispec{stripe customer create (api: stripe\_customer\_create)}{paymentId: str (*req), name: str, email: str, description: str}
{No documentation yet.}
\apispec{stripe customer get (api: stripe\_customer\_get)}{customerId: str (*req)}
{No documentation yet.}
\apispec{stripe customer payment add (api: stripe\_customer\_payment\_add)}{paymentMethodId: str (*req), customerId: str (*req)}
{No documentation yet.}
\apispec{stripe customer payment delete (api: stripe\_customer\_payment\_delete)}{paymentMethodId: str (*req)}
{No documentation yet.}
\apispec{stripe customer payment get (api: stripe\_customer\_payment\_get)}{customerId: str (*req)}
{No documentation yet.}
\apispec{stripe customer payment default (api: stripe\_customer\_payment\_default)}{customerId: str (*req), paymentMethodId: str (*req)}
{No documentation yet.}
\apispec{stripe subscription create (api: stripe\_subscription\_create)}{paymentId: str (*req), name: str (*req), email: str (*req), priceId: str (*req), customerId: str (*req)}
{TODO: name and email parameters not used!}
\apispec{stripe subscription delete (api: stripe\_subscription\_delete)}{subscriptionId: str (*req)}
{No documentation yet.}
\apispec{stripe subscription get (api: stripe\_subscription\_get)}{customerId: str (*req)}
{No documentation yet.}
\apispec{stripe invoices list (api: stripe\_invoices\_list)}{customerId: str (*req), subscriptionId: str (*req), limit: int, lastItem: str}
{No documentation yet.}
\subsection{APIs for super}

No documentation yet.

\apispec{master createsuper (api: master\_createsuper)}{name: str (*req), set_active: bool, other_fields: dict}
{other fields used for additional feilds for overloaded interfaces
(i.e., Dango interface)}
\apispec{master allusers (api: master\_allusers)}{num: int, start_idx: int}
{return and start idx specfies where to start
NOTE: Abstract interface to be overridden}
\apispec{master become (api: master\_become)}{mast: master (*req)}
{No documentation yet.}
\apispec{master unbecome (api: master\_unbecome)}{n/a}
{No documentation yet.}
\subsection{APIs for walker}

No documentation yet.

\apispec{walker callback (api: walker\_callback)}{nd: node (*req), wlk: walker (*req), key: str (*req), ctx: dict, _req_ctx: dict, global_sync: bool}
{along with the walker id and node id}
\apispec{walker summon (api: walker\_summon)}{key: str (*req), wlk: walker (*req), nd: node (*req), ctx: dict, _req_ctx: dict, global_sync: bool}
{along with the walker id and node id}
\apispec{walker register (api: walker\_register)}{snt: sentinel, code: str, encoded: bool}
{No documentation yet.}
\apispec{walker get (api: walker\_get)}{wlk: walker (*req), mode: str, detailed: bool}
{Valid modes: {default, code, ir, keys, }}
\apispec{walker set (api: walker\_set)}{wlk: walker (*req), code: str (*req), mode: str}
{Valid modes: {code, ir, }}
\apispec{walker list (api: walker\_list)}{snt: sentinel, detailed: bool}
{No documentation yet.}
\apispec{walker delete (api: walker\_delete)}{wlk: walker (*req), snt: sentinel}
{No documentation yet.}
\apispec{walker spawn create (api: walker\_spawn\_create)}{name: str (*req), snt: sentinel}
{No documentation yet.}
\apispec{walker spawn delete (api: walker\_spawn\_delete)}{name: str (*req)}
{No documentation yet.}
\apispec{walker spawn list (api: walker\_spawn\_list)}{detailed: bool}
{No documentation yet.}
\apispec{walker prime (api: walker\_prime)}{wlk: walker (*req), nd: node, ctx: dict, _req_ctx: dict}
{No documentation yet.}
\apispec{walker execute (api: walker\_execute)}{wlk: walker (*req), prime: node, ctx: dict, _req_ctx: dict, profiling: bool}
{No documentation yet.}
\apispec{walker run (api: walker\_run)}{name: str (*req), nd: node, ctx: dict, _req_ctx: dict, snt: sentinel, profiling: bool}
{reports results, and cleans up walker instance.}
\apispec{wapi (api: wapi)}{name: str (*req), nd: node, ctx: dict, _req_ctx: dict, snt: sentinel, profiling: bool}
{No documentation yet.}
