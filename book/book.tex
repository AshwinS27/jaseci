
\documentclass{book}
\usepackage[utf8]{inputenc}
\usepackage{subcaption}
\usepackage{graphicx}
\usepackage[toc]{glossaries}
\newglossary[tlg]{technical}{tld}{tdn}{Techinical Terms}
\makeglossaries
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

 
\title{Jaseci and Jac}
\author{Jason Mars}

\input{figures.tex}
\begin{document}

% \chapter*{Copyright}
% \chapter*{Acknowledgments}
% \addcontentsline{toc}{chapter}{Acknowledgments}
% \chapter*{How To Send Feedback}

\cleardoublepage % Make toc appear on right side.
\setcounter{secnumdepth}{3} % toc is 2 level deep.
\tableofcontents
\pagebreak
\printglossary[title=Terms Used, toctitle=List of Terms]
\printglossary[type=technical, title=Technical Terms Used, toctitle=List of Technical Terms]


\chapter*{Preface}
\addcontentsline{toc}{chapter}{Preface}

The way we design and write software to do computation and AI today sucks. It's a vat of boiling poop, mixed with pee, slowly swirling and bubbling toward that dehydrated semi-solid state of goop that serves to repel and repulse most normal people only attracting the few unfortunate-fortunate folks that happen to be obsessed with \gls{scat}.
\paragraph{}
Hrm, too much? Probably. I guess you'd expect me to use concrete examples and cite evidence to make my points, me being a professor and all. I mean, I could write something like \textit{``The fundamental imperative programming model utilized in near all of the production software produced in the last four decades has not changed since blah blah blah..."} to meet expections. I'd certainly sound more credible and perhaps super smart. Well, I'm not going to do that here. Let's have fun. Afterall, Jaseci has never been work for me, its play. Very ambitious play granted, but play at it's core.
\paragraph{}
Everything here is based on my opinion and intution. That suffices for me, and I hope it does for you. I have spent many decades coding and leading teams who code, but its my gut that tells me that we can do better. This book describes my attempt at better. I hope you find value in it. If you do, awesome! If you don't, also awesome.


\chapter{Introduction}


\chapter{What and Why is Jaseci?}
\section{Viewing the Problem Landscape Spacially}
\section{Compute via The Collective, The Worker Bee Model}

\chapter{Abstrations of Jaseci}
\section{Graphs}
There's something quite strange that has happend with our \gls{common languages} over the years, ...decades. When you look at it, almost every data structure we programmers use to solve problems can be modeled formally as a graph, or a special case of a graph, (save perhaps hash tables). However no common language ustilizes the formal semantics of a graph as its first order abstraction for data or memory. I mean think about it, isn't it a bit odd that practically every data structure covered in the language-agnostic classic foundational work \textit{Introduction to Algorithms}~\cite{intro_to_algo} can most naturally be be reasoned about as a graph, yet none of the common languages have built in and be designed around this primitive. I submit that the graph semantic is stupidly rich, very nice for us humans to reason about, and, most importantly for the purpose of Jaseci, is inherently well suited for a spacial conceptualization and reasoning about computational problems.
\paragraph{}
There are a few arguments that may pop into one's mind at this point of my conjecture.
\begin{itemize}
    \item ``Well there are graph libraries in my favorite language that implement graph symantics, why would I need a language to force the concept upon me?''
          or
    \item ``Duh! Interacting wi th all data and memory through graphical abstractions will make the language slow as hell since memory in hardware is essitially a big array, what is this dude talking about!?!?''
\end{itemize}
\paragraph{}
For the former question, I counter with two points. First, the core design of a language will be based upon its inherent abstractions, and with graphs not being one such abstraction the language design isn't optimized to empower programmers to nimbly do fancy gymnastics with the rich symantics of graphs. And second, libraries suck (See~\ref{rant:librariessuck}).
\paragraph{}
For the latter question, I'd respond, ``Have you SEEN the kind of abstractions in modern languages!?!? It's rediculous, lets look at python dictionaries, actually scratch that, lets keep it simple and look at dynamic typing in general. The runtime complexity to support dynamic typing is most certainly hgiher than a graph abstraction. Duh right back at'ya!''
\subsection{Yes, But What Kind of Graphs}
\printfigTypes
There are many categories of graphs to consider when thinking about the abstractions to add to Jaseci. There are rules to be defined as to the availabe semantics of the graphs. Should all graphs be \gls{directed graphs}, should we allow the creation of \gls{undirected graphs}, what about parallel edges or \gls{multigraphs}, are those explicitly expressible, can we express \gls{hypergraphs}, and what combination of these graphical sematics can be manifested and manipulated through the programming model. At this point I can feel your eyes getting droopy and your mind moving into that intermediary state between concious and sleeping, so let me cut to the answer.
\paragraph{}
In Jaseci, we elect to assume the following semantics:
\begin{enumerate}
    \item Graphs are directed with a special case of a doubly directed edge type (which can be utilized practically as an undirected edge).
    \item Both nodes and edges have their own distinct identities (i,e. an edge isn't representable as a pairing of two nodes). This point is important as both nodes and edges can have a context.
    \item Multigraphs (i.e., parallel edges) are allowed, including self-loop edges.
    \item No hypergraphs as I wouldn't want my programmers heads to explode.
    \item As an aside, I would describe Jaseci graphs as strictly directed multigraphs  for which that leverages the semantics of parallel edges to create a laymans `undirected edge' by shorthanding two directed edges pointed in opposite directions between the same two nodes.
\end{enumerate}
[NERD ALERT] I'd formally describe a Jaseci Graph as,
[END NERD ALERT]

\subsection{Contexts}
\subsection{Nodes}
\subsection{Edges}

\section{Walkers}
\section{Abilities}
\section{Other Abstractions Not Yet Actualized}

\chapter{Architecture of Jaseci and Jac}
\section{Anatomy of a Jaseci Application}
\section{The Jaseci Machine}
\subsection{Machine Core}
\subsection{Jaseci Cloud Server}

\chapter{Interfacing a Jaseci Machine}
\section{JSCTL: The Jaseci Command Line Interface}
\section{Jaseci Rest API}

\chapter{The Jac Programming Language}


\chapter{Architecting Jaseci Core}


\chapter{Architecting Jaseci Cloud Serving}

\chapter*{Epilogue}
\addcontentsline{toc}{chapter}{Epilogue}

\appendix
\chapter{Rants}
\section{Why Libraries Suck}
\label{rant:librariessuck}
\paragraph{}
Because they do.
\paragraph{}
Still need more reasons?
\paragraph{}
Well, if you dont already know, I'm not going to tell you.
\paragraph{}
Fine, I'll tell you.
\begin{enumerate}
    \item They suck because they create dependancies for which you must have faith in the implementer of the library to maintain and keep bug free.
    \item They suck because there are often at least 10 options to choose from with near exact features expressings slightly different idosyncratic ways.
    \item They suck because they suck.
\end{enumerate}
Don't get me wrong, we have to use libraries. I'm not saying go reimplement the wheel 15 thousand times over. But that doesn't mean they don't suck and should be avoided if possible. The best is to know your library inside and out so the moment you hit some suckitude you can pull in the library's source code into your own codebase and \gls{pwn} it as your own.

\input{glossary.tex}

\bibliographystyle{plain}
\bibliography{book}
\end{document}
